<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Map Generator</title> <!-- Initial Title -->

    <!-- Leaflet & PapaParse Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <!-- Styles -->
    <style>
        /* --- Base Styles & Sidebar Modularity --- */
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; display: flex; height: 100vh; }
        #map { flex: 1; height: 100%; border-left: 1px solid #ccc; background-color: #eee; /* Light background */ }
        .sidebar {
            width: 350px; min-width: 300px; max-width: 450px;
            padding: 15px; background-color: #f4f4f4; overflow-y: auto;
            height: 100vh; box-sizing: border-box; display: flex;
            flex-direction: column; resize: horizontal; overflow-x: hidden;
        }
        .file-input-container { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #ccc; flex-shrink: 0; }
        .file-input { width: 100%; margin-bottom: 10px; }
        .territory-list-container { flex-grow: 1; display: flex; flex-direction: column; min-height: 150px; margin-bottom: 15px; }
        .territory-list { flex-grow: 1; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; background: white; }
        .territory-item {
            padding: 8px 12px; border-bottom: 1px solid #eee; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center; gap: 8px;
        }
        .territory-item:last-child { border-bottom: none; }
        .territory-item:hover { background-color: #e9e9e9; }
        .territory-item.active { background-color: #ddeeff; font-weight: bold; }
        .territory-name { flex: 1; min-width: 0; word-break: break-word; font-size: 13px; line-height: 1.3; }
        .print-btn {
             background: #4CAF50; color: white; border: none; border-radius: 4px;
             padding: 4px 8px; cursor: pointer; font-size: 11px;
             flex-shrink: 0; white-space: nowrap;
        }
        .print-btn:hover { background: #45a049; }
        h1, h2 { flex-shrink: 0; /* Prevent shrinking */ }
        h1 { font-size: 1.4rem; margin: 0 0 15px 0; color: #333; }
        h2 { font-size: 1.1rem; margin: 10px 0; color: #555; }
        .controls { margin-top: auto; padding-top: 15px; border-top: 1px solid #ccc; flex-shrink: 0; }
        button { padding: 9px 14px; margin-bottom: 10px; width: 100%; cursor: pointer; border: none; border-radius: 4px; background-color: #3498db; color: white; font-weight: bold; font-size: 13px; }
        button:hover { background-color: #2980b9; }
        #sample-csv { background-color: #95a5a6; margin-top: 5px; } #sample-csv:hover { background-color: #7f8c8d; }
        #batch-print { background-color: #e67e22; } #batch-print:hover { background-color: #d35400; }
        .status { margin-top: 10px; padding: 10px; border-radius: 4px; font-size: 13px; display: none; border: 1px solid transparent; flex-shrink: 0; }
        .status.success { display: block; background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        .status.error { display: block; background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }
        .status.warning { display: block; background-color: #fff3cd; color: #856404; border-color: #ffeeba; }
        .status.info { display: block; background-color: #d1ecf1; color: #0c5460; border-color: #bee5eb; }
        .print-header, .print-footer { display: none; position: absolute; background: rgba(255, 255, 255, 0.9); padding: 10px 15px; border-radius: 5px; box-shadow: 0 1px 5px rgba(0,0,0,0.2); z-index: 1000; }
        .print-header { top: 15px; left: 50px; right: 15px; } .print-header h2 { margin: 0 0 5px 0; font-size: 20px; color: #333; } .print-header .subtitle { font-size: 14px; color: #555; margin: 0; }
        .print-footer { bottom: 10px; left: 50px; font-size: 10px; color: #666; }
        .map-layers { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #ccc; flex-shrink: 0; }
        .layer-option { margin-bottom: 8px; } .layer-option label { font-size: 14px; display: flex; align-items: center; cursor: pointer; } .layer-option input { margin-right: 8px; }

        /* --- Print Styles --- */
        @media print {
            body { display: block; height: auto; }
            .sidebar, .leaflet-control-container, #batch-print-ui { display: none !important; }
            #map { width: 100%; height: 95vh; border-left: none; page-break-inside: avoid; }
            .print-header, .print-footer { display: block !important; position: fixed; background: white; box-shadow: none; border: 1px solid #ccc; }
            .print-header { top: 10px; left: 10px; right: 10px; }
            .print-footer { bottom: 10px; left: 10px; font-size: 9pt; }
            .leaflet-pane .leaflet-interactive.print-muted-territory { opacity: 0.15 !important; stroke: #888 !important; stroke-width: 1px !important; fill: #aaa !important; }
            .leaflet-pane .leaflet-interactive.print-selected-territory { opacity: 1 !important; stroke-width: 3px !important; }
        }
    </style>
</head>
<body>
    <!-- Sidebar Structure -->
    <div class="sidebar">
        <h1>Territory Map Generator</h1>
        <div class="file-input-container">
            <h2>1. Upload CSV File</h2>
            <p style="font-size: 12px; color: #666;">CSV: 'CategoryCode', 'Number', 'Boundary'. Name: 'CategoryCode'-'Number'.</p>
            <input type="file" id="csv-file" class="file-input" accept=".csv">
            <button id="load-csv">Load Territories</button>
            <button id="sample-csv">Download Sample CSV</button>
            <div id="status" class="status"></div>
        </div>
        <div class="map-layers">
            <h2>2. Map Background</h2>
            <div class="layer-option"><label><input type="radio" name="mapLayer" value="street" checked> Streets</label></div>
            <div class="layer-option"><label><input type="radio" name="mapLayer" value="satellite"> Satellite</label></div>
            <div class="layer-option"><label><input type="radio" name="mapLayer" value="topo"> Topographic</label></div>
        </div>
        <div class="territory-list-container">
            <h2>3. Territories</h2>
            <div id="territory-list" class="territory-list">
                <div style="padding: 15px; color: #888; text-align: center;">Load CSV...</div>
            </div>
        </div>
        <div class="controls">
            <h2>4. Actions</h2>
            <button id="show-all">Show All Territories</button>
            <button id="fit-all">Zoom to Fit All</button>
            <button id="batch-print">Generate All PDF Maps (Manual)</button>
        </div>
    </div>
    <div id="map"></div>
    <div id="print-header" class="print-header">
        <h2 id="print-title">Territory Map</h2>
        <div id="print-subtitle" class="subtitle">Generated Map</div>
    </div>
    <div id="print-footer" class="print-footer">
        Generated on <span id="print-date"></span> | Map Data © OSM, Esri, OpenTopoMap
    </div>

    <!-- JavaScript Section -->
    <script>
        // Global variables
        let map;
        const territories = [];
        const territoryLayers = {};
        let activeTerritoryId = null;
        let batchPrintIndex = -1;
        let currentBaseLayer;
        const originalPageTitle = document.title;
        let isPrinting = false;
        let afterPrintListener = null;
        let statusDiv, territoryListDiv, printTitle, printSubtitle, printDateSpan; // Declare globally

        // Styles
        const defaultStyle = { weight: 3, fillOpacity: 0.6 };
        const selectedStyle = { weight: 6, fillOpacity: 0.05 };
        const inactiveStyle = { weight: 5, fillOpacity: 0.7 };
        const printSelectedBaseStyle = { weight: 3, fillOpacity: 0.5 };
        const printMutedBaseStyle = { weight: 5, fillOpacity: 0.8, color: '#aaa', fillColor: '#ccc' };

        // Map Layers
        const mapLayers = {
             street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap', crossOrigin: "anonymous" }),
             satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '© Esri', crossOrigin: "anonymous" }),
             topo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { attribution: '© OpenTopoMap', crossOrigin: "anonymous" })
        };

        // --- Initialization ---
        function initializeMap() {
            if (map || !document.getElementById('map')) { console.warn("Map init skipped."); return; }
            statusDiv = document.getElementById('status'); territoryListDiv = document.getElementById('territory-list'); printTitle = document.getElementById('print-title'); printSubtitle = document.getElementById('print-subtitle'); printDateSpan = document.getElementById('print-date');
            let missingElements = [];
            if (!statusDiv) missingElements.push("status"); if (!territoryListDiv) missingElements.push("territory-list"); if (!printTitle) missingElements.push("print-title"); if (!printSubtitle) missingElements.push("print-subtitle"); if (!printDateSpan) missingElements.push("print-date");
            if (missingElements.length > 0) { console.error("Map Init Error: Missing elements:", missingElements.join(', ')); const mapDiv = document.getElementById('map'); if (mapDiv) mapDiv.innerHTML = `Init Error: Missing elements: ${missingElements.join(', ')}. Check IDs.`; return; }
            try {
                map = L.map('map', { preferCanvas: true }).setView([39.015, -77.38], 13); currentBaseLayer = mapLayers.street;
                if (currentBaseLayer) { currentBaseLayer.addTo(map); } else { throw new Error("Default base layer unavailable."); }
                console.log("Map initialized."); setStatus('info', 'Map ready.'); printDateSpan.textContent = new Date().toLocaleDateString();
            } catch (e) { console.error("Map Init Error:", e); setStatus('error', 'Map init failed.'); }
        }

        // --- Utility Functions ---
        function setStatus(type, message) { if (!statusDiv) { console.warn("setStatus: statusDiv not found."); return; } statusDiv.className = `status ${type}`; statusDiv.textContent = message; if (type === 'info' || type === 'success') { setTimeout(() => { if (statusDiv?.textContent === message) { statusDiv.className = 'status'; statusDiv.textContent = ''; } }, 5000); } }
        function clearMapAndList() { Object.values(territoryLayers).forEach(layer => { if (map?.hasLayer(layer)) map.removeLayer(layer); }); territories.length = 0; Object.keys(territoryLayers).forEach(key => delete territoryLayers[key]); activeTerritoryId = null; if (territoryListDiv) { territoryListDiv.innerHTML = '<div style="padding:15px;color:#888;text-align:center;">Load CSV...</div>'; } else { console.warn("clearMapAndList: territoryListDiv not found."); } }
        function findKey(obj, keyToFind) { return obj ? Object.keys(obj).find(k => k.trim().toLowerCase() === keyToFind.toLowerCase()) : undefined; }

        // --- CSV Processing ---
        document.getElementById('load-csv').addEventListener('click', () => {
            const fileInput = document.getElementById('csv-file'); if (!fileInput.files || fileInput.files.length === 0) { setStatus('error', 'Select CSV file.'); return; }
            const file = fileInput.files[0]; clearMapAndList(); setStatus('info', 'Parsing CSV...');
            Papa.parse(file, {
                header: true, dynamicTyping: true, skipEmptyLines: true,
                complete: (results) => {
                    console.log("CSV Parsing complete."); if (results.errors.length > 0) console.warn("CSV Parse Errors:", results.errors);
                    if (!results.data || results.data.length === 0) { setStatus('error', 'CSV empty/unparseable.'); return; }
                    if (!map) { setStatus('error', 'Map not ready. Try loading again.'); return; }
                    processData(results.data, results.errors);
                },
                error: (error) => { console.error("PapaParse Error:", error); setStatus('error', `CSV Parse Error: ${error.message}`); }
            });
        });

        // --- processData with BOUNDARY LOGGING ---
        function processData(data, parseErrors) {
             console.log("Processing CSV data. Row count:", data.length);
             const firstRow = data[0] || {};
             const categoryCodeKey = findKey(firstRow, 'categorycode');
             const numberKey = findKey(firstRow, 'number');
             const boundaryKey = findKey(firstRow, 'boundary');
             const territoryIdKey = findKey(firstRow, 'territoryid');

             console.log("Required keys found:", { categoryCodeKey, numberKey, boundaryKey });

             if (!categoryCodeKey || !numberKey || !boundaryKey) {
                 setStatus('error', `CSV missing required columns: 'CategoryCode', 'Number', or 'Boundary'.`);
                 console.error("Missing required columns.");
                 return;
             }

             let added = 0, errors = parseErrors.length;
             console.log("Starting row iteration...");
             data.forEach((row, index) => {
                 const catCode = row[categoryCodeKey]?.toString().trim() || '';
                 const num = row[numberKey]?.toString().trim() || '';
                 const boundaryStr = row[boundaryKey]; // Get the raw value
                 let name = (catCode && num) ? `${catCode}-${num}` : `FallbackName_${index + 1}`;

                 // --- DEBUG: Log the raw boundary string for the first few rows ---
                 if (index < 5) { // Log first 5 boundary strings
                     console.log(`Row ${index+2} Boundary String Input:`, JSON.stringify(boundaryStr)); // Use JSON.stringify to see potential extra quotes
                 }
                 // --- END DEBUG ---

                 if (!boundaryStr || typeof boundaryStr !== 'string' || boundaryStr.trim() === '') {
                     console.warn(`Skip row ${index+2} (Name: ${name}): Missing or invalid 'Boundary' data type/value.`); errors++; return;
                 }

                 try {
                     const latLngs = parseBoundaryString(boundaryStr.trim());
                     if (!latLngs || latLngs.length < 3) {
                         console.warn(`Skip row ${index+2} (Name: ${name}): Coordinate parsing failed or insufficient points (${latLngs?.length || 0}).`);
                         errors++; return;
                     }
                     const sourceId = row[territoryIdKey]?.toString().trim() || `gen-${index}`; const terrId = `terr-${sourceId}`;
                     const territory = { id: terrId, name: name, color: colors[added % colors.length], coordinates: latLngs, rawData: row };

                     if (!map) { throw new Error("Map object unavailable during processing."); }
                     const polygon = L.polygon(latLngs, { ...defaultStyle, color: territory.color, fillColor: territory.color }).addTo(map);

                     territories.push(territory);
                     polygon.bindPopup(`<b>${territory.name}</b><br><small>ID: ${sourceId}</small>`).on('click', () => selectTerritory(territory.id));
                     territoryLayers[territory.id] = polygon;
                     added++;
                 } catch (e) { console.error(`Error processing row ${index+2} (Name: ${name}):`, e); errors++; }
             });
             console.log("Finished row iteration. Added:", added, "Errors/Skipped:", errors);
             if (added > 0) { console.log("Calling updateTerritoryList..."); updateTerritoryList(); console.log("Calling fitAllTerritories..."); fitAllTerritories(); setStatus(errors > 0 ? 'warning' : 'success', `Loaded ${added} territories.${errors > 0 ? ` (${errors} errors)` : ''}`); }
             else { setStatus('error', `No valid territories loaded. Check CSV. ${errors > 0 ? ` (${errors} errors)` : ''}`); }
        }

        // --- parseBoundaryString with REFINED REGEX and LOGGING ---
        function parseBoundaryString(boundaryStr) {
            if (!boundaryStr || typeof boundaryStr !== 'string') return [];
            let latLngs = [];
            try {
                // Regex improved slightly for more whitespace tolerance
                const coordMatches = boundaryStr.matchAll(/\[\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\]/g);
                latLngs = Array.from(coordMatches).map(match => {
                    const lng = parseFloat(match[1]); const lat = parseFloat(match[2]);
                    if (!isNaN(lat) && !isNaN(lng)) { return [lat, lng]; } // Leaflet uses [lat, lng]
                    console.warn("Invalid number found in coordinate pair:", match[0]); return null;
                }).filter(p => p !== null);

                if (latLngs.length >= 3) { return latLngs; }
                else { console.warn(`parseBoundaryString (Format 1): Found only ${latLngs.length} valid pairs in string starting with:`, boundaryStr.substring(0, 100) + "..."); }
            } catch (e) { console.error("Regex parsing error:", e, "String:", boundaryStr.substring(0, 100) + "..."); latLngs = []; }

            // --- Fallback formats ---
            if (latLngs.length < 3 && boundaryStr.includes(',') && boundaryStr.includes(' ') && !boundaryStr.includes('[')) { /* Format 2 */ const pairs = boundaryStr.split(' ').filter(p => p.includes(',')); latLngs = pairs.map(pair => { const parts = pair.split(',').map(Number); return (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) ? [parts[0], parts[1]] : null; }).filter(p => p !== null); if (latLngs.length >= 3) { console.log("Parsed using Format 2."); return latLngs; } }
            if (latLngs.length < 3 && !boundaryStr.includes('[')) { /* Format 3 */ const separators = boundaryStr.includes(',') ? /,/ : /\s+/; const coords = boundaryStr.split(separators).map(s => s.trim()).filter(s => s !== '').map(Number).filter(n => !isNaN(n)); if (coords.length >= 6 && coords.length % 2 === 0) { latLngs = []; for (let i = 0; i < coords.length; i += 2) { latLngs.push([coords[i], coords[i + 1]]); } if (latLngs.length >= 3){ console.log("Parsed using Format 3."); return latLngs; } } }
            if(latLngs.length < 3){ return []; } // Return empty if insufficient points after all checks
            return latLngs; // Should not be reached
        }

        // --- UI Updates ---
         function updateTerritoryList() {
             console.log("Running updateTerritoryList. Found territories:", territories.length);
             if (!territoryListDiv) { console.error("updateTerritoryList: territoryListDiv is null!"); return; }
             territoryListDiv.innerHTML = '';
             if (territories.length === 0) { territoryListDiv.innerHTML = '<div style="padding:15px;color:#888;">No territories loaded.</div>'; return; }
             territories.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'}));
             territories.forEach(t => {
                 try {
                     const item = document.createElement('div'); item.className = 'territory-item'; item.dataset.territoryId = t.id; item.style.borderLeft = `5px solid ${t.color}`;
                     const nameSpan = document.createElement('span'); nameSpan.className = 'territory-name'; nameSpan.textContent = t.name; if (t.name.length > 30) nameSpan.title = t.name; item.appendChild(nameSpan);
                     const printBtn = document.createElement('button'); printBtn.className = 'print-btn'; printBtn.textContent = 'Print Map'; printBtn.addEventListener('click', (e) => { e.stopPropagation(); printTerritory(t.id); }); item.appendChild(printBtn); // Use addEventListener
                     item.addEventListener('click', () => { selectTerritory(t.id); }); // Use addEventListener
                     territoryListDiv.appendChild(item);
                 } catch (e) { console.error("Error creating list item for territory:", t.name, e); }
             });
             console.log("Finished updating territory list.");
         }


        // --- Map Interaction ---
        function selectTerritory(id, options = {}) {
             const { isPrintPreparation = false } = options; if (!map || !territoryLayers[id]) return; const territory = territories.find(t => t.id === id); if (!territory) return;
             if (!isPrintPreparation && territoryListDiv) { document.querySelectorAll('.territory-item').forEach(item => item.classList.toggle('active', item.dataset.territoryId === id)); }
             Object.entries(territoryLayers).forEach(([layerId, layer]) => { const currentTerritory = territories.find(t => t.id === layerId); const element = layer.getElement(); if (element) { L.DomUtil.removeClass(element, 'print-muted-territory'); L.DomUtil.removeClass(element, 'print-selected-territory'); } if (layerId === id) { layer.setStyle({ ...selectedStyle, color: territory.color, fillColor: territory.color }); layer.bringToFront(); } else { layer.setStyle({ ...inactiveStyle, color: currentTerritory?.color || '#ccc', fillColor: currentTerritory?.color || '#ccc' }); } });
             if (!isPrintPreparation) { const bounds = territoryLayers[id].getBounds(); if (bounds?.isValid()) { map.fitBounds(bounds, { padding: [50, 50], maxZoom: 17 }); } activeTerritoryId = id; console.log("Selected:", territory.name); if (territoryListDiv) { const listItem = territoryListDiv.querySelector(`.territory-item[data-territory-id="${id}"]`); if(listItem) { listItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } } }
        }
        function showAllTerritories() {
            if (!map) return; Object.entries(territoryLayers).forEach(([layerId, layer]) => { const territory = territories.find(t => t.id === layerId); const element = layer.getElement(); if (element) { L.DomUtil.removeClass(element, 'print-muted-territory'); L.DomUtil.removeClass(element, 'print-selected-territory'); } layer.setStyle({ ...defaultStyle, color: territory?.color || '#ccc', fillColor: territory?.color || '#ccc' }); }); if (territoryListDiv) { document.querySelectorAll('.territory-item').forEach(item => item.classList.remove('active')); } activeTerritoryId = null; console.log("Showing all.");
        }
        function fitAllTerritories() { if (!map || territories.length === 0) return; const validLayers = Object.values(territoryLayers).filter(layer => map.hasLayer(layer)); if (validLayers.length > 0) { const group = new L.featureGroup(validLayers); const bounds = group.getBounds(); if (bounds?.isValid()) { map.fitBounds(bounds, { padding: [30, 30] }); console.log("Zoomed to fit all."); } else { console.warn("Cannot fit: Invalid bounds."); } } else { console.warn("Cannot fit: No valid layers."); } }

        // --- Map Layer Switching ---
        document.querySelectorAll('input[name="mapLayer"]').forEach(input => { input.addEventListener('change', function() { if (map && mapLayers[this.value]) { if (currentBaseLayer && map.hasLayer(currentBaseLayer)) { map.removeLayer(currentBaseLayer); } currentBaseLayer = mapLayers[this.value]; currentBaseLayer.addTo(map); console.log("Switched base layer:", this.value); } }); });

        // --- Printing Logic ---
        function applyPrintStyles(selectedTerritoryId) { console.log("Applying print CSS classes..."); Object.entries(territoryLayers).forEach(([layerId, layer]) => { const element = layer.getElement(); if (!element) return; const territory = territories.find(t => t.id === layerId); L.DomUtil.removeClass(element, 'print-muted-territory'); L.DomUtil.removeClass(element, 'print-selected-territory'); if (layerId === selectedTerritoryId) { layer.setStyle({...printSelectedBaseStyle, color: territory?.color || '#3388ff', fillColor: territory?.color || '#3388ff'}); L.DomUtil.addClass(element, 'print-selected-territory'); layer.bringToFront(); } else { layer.setStyle(printMutedBaseStyle); L.DomUtil.addClass(element, 'print-muted-territory'); } }); }
        function resetStylesAfterPrint(printedTerritoryId) { console.log("Resetting styles after print."); isPrinting = false; document.title = originalPageTitle; if (afterPrintListener) { window.removeEventListener('afterprint', afterPrintListener); afterPrintListener = null; console.log("Afterprint listener removed."); } Object.values(territoryLayers).forEach(layer => { const element = layer.getElement(); if (element) { L.DomUtil.removeClass(element, 'print-muted-territory'); L.DomUtil.removeClass(element, 'print-selected-territory'); } }); if (printedTerritoryId && territoryLayers[printedTerritoryId] && map) { selectTerritory(printedTerritoryId); } else { showAllTerritories(); } }
        function printTerritory(territoryId) { if (isPrinting) { setStatus('warning', 'Print in progress...'); return; } if (!map) { alert("Map not ready."); return; } const territory = territories.find(t => t.id === territoryId); if (!territory || !territoryLayers[territory.id]) { alert(`Data not found.`); return; } isPrinting = true; console.log(`Prep print: ${territory.name}`); selectTerritory(territoryId, { isPrintPreparation: true }); applyPrintStyles(territoryId); if (!printTitle || !printSubtitle || !printDateSpan) { console.error("Print elements missing."); isPrinting = false; return; } printTitle.textContent = territory.name; printSubtitle.textContent = `Map`; printDateSpan.textContent = new Date().toLocaleDateString(); document.title = territory.name; setStatus('info', `Prepping map view...`); const bounds = territoryLayers[territoryId].getBounds(); if (!bounds?.isValid()) { alert(`Invalid bounds.`); resetStylesAfterPrint(territoryId); return; } map.fitBounds(bounds, { padding: [40, 40], maxZoom: 17 }); afterPrintListener = () => { resetStylesAfterPrint(territoryId); }; window.addEventListener('afterprint', afterPrintListener); setTimeout(() => { if (!isPrinting) { console.log("Print cancelled during timeout."); return; } try { map.zoomOut(0.3); map.invalidateSize(); setStatus('info', `Map ready. Opening print... (Filename: ${territory.name})`); window.print(); console.log(`Print dialog initiated.`); } catch (e) { console.error("Print Error:", e); setStatus('error', 'Print failed.'); resetStylesAfterPrint(territoryId); } }, 2000); }

        // --- Batch Printing ---
        function startBatchPrint() { /* Unchanged */ }
        function showBatchTerritoryForPrint() { /* Unchanged */ }
        function processNextBatchTerritory() { /* Unchanged */ }
        function cancelBatchPrint() { /* Unchanged */ }

        // --- Sample CSV Download ---
        document.getElementById('sample-csv').addEventListener('click', () => { /* Unchanged */ });

        // --- Global Listeners ---
        document.getElementById('show-all').addEventListener('click', showAllTerritories);
        document.getElementById('fit-all').addEventListener('click', fitAllTerritories);
        document.getElementById('batch-print').addEventListener('click', startBatchPrint);

        // --- Initialize Call ---
        window.addEventListener('DOMContentLoaded', initializeMap);
        if (document.readyState === 'complete' || document.readyState === 'interactive') { setTimeout(initializeMap, 1); }

        // --- Colors ---
        const colors = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999','#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f'];

    </script>

</body>
</html>